/*
 A very simple (abstract/tracing) interpreter that takes in the AST generated by js_astify.js. Inteprets only a fragment of javascript (eg does not deal with objects, loops, etc.).
 The traces generated are in an even simpler js fragment, that has no non-primitive function call, no loops, etc. It is:
 S    :=   A_i|I|SS
 A_i  :=   var abi = primfn(ab,..)
 I    :=   if(ab1){S;A_i} else {S;A_i}
 Note that the assigned variable in A_i in both if branches is the same. Otherwise variables are assigned only once.
 
 
 FIXME:
 -fix kludge to call ERPs (in evaluate.js)...
 -switch to a better direct conditioning interface for probjs, that doesn't look like arguments.
 -need to add standard precompile environment for higher order fns.
 -when max-depth reach, generated code isn't going to have symbols defined.. need to add wrapper that asisgns all names in interpreter environment when code is generated.
 -should keep around locs for error traces. this means using only ASTs, not direct code.
 -we trace closures more times than needed. trace when closure is created instead of used?

 
 Notes:
 -One special kind of randomChoice is those guaranteed to exist. Those can get simple static names. Can detect from the interpretation by passing down whether we are in an (abstract) if branch.
 -Another special kind of randomChoice are the non-structural ones.
 
 -Within code generated by tracing, don't need enter/leave wrapping. Only right before randomChoice or untraced fall-through. (Higher-order primitives?) Mark other calls with callskip for wctransform?
 
 -Trace through ERP lookup (scoring / sampling)? Through church arithmetic primitives?
 
 in probjs:
 -Add notation for guaranteed random choices.
 -Guaranteed rcs should have different (fast) lookup path.
 -Non-structural proposals use flat list
 
 */


var escodegen = require('escodegen');
var esprima = require('esprima');
var tokenize = require('./tokenize.js').tokenize;
var church_astify = require('./church_astify.js').church_astify;
var js_astify = require('./js_astify.js').church_tree_to_esprima_ast;
var builtins = require('./church_builtins');
var erp = require('./probabilistic/erp.js')
var pr = require('./probabilistic/index.js')
pr.openModule(pr)//make probjs fns available.

////// make erp exports directly avaialable (gnarly use of eval to get in scope):
//for (var prop in erp) {
//    eval(prop + "= erp."+prop)
//}






//the ERPs that have to be intercepted from church_builtins:
//copy builtins since we'll be overloading some:
var church_builtins = {}
for (var b in builtins) {church_builtins[b] = builtins[b];}
//add abstract objects for the ERPs to the church_builtins:
var erps = ["wrapped_uniform_draw", "wrapped_multinomial", "wrapped_flip", "wrapped_uniform", "wrapped_random_integer", "wrapped_gaussian", "wrapped_gamma", "wrapped_beta", "wrapped_dirichlet"]
for (var p in erps) {
    var e = erps[p]
    church_builtins[e] = function(x) {return function() {
        var args = Array.prototype.slice.call(arguments)
        var ret = new Abstract()
        global_trace.push("var "+valString(ret)+" = random(church_builtins." + x +", "+ valString(args) +");")
        return ret
    }}(e)
}
//now we're going to add some compiled HOFs to the church_builtins:
//compile a def to js_ast, extract that closure from the env, bind it to a church_builtins
//church_builtins.repeat = js_astify(church_astify(tokenize()))


function precompile(church_codestring) {
    
    //prepend the standard preamble:
    //stdEnv_code = require('fs').readFileSync("./precompile_stdenv.church", "utf8");
    var preamble = "" //FIXME: (most of?) the higher-order functions we want to overload are in church_builtins
    church_codestring = preamble + church_codestring
    //FIXME: kludge works around vararg interaction with direct conditioning....
    church_codestring = church_codestring.replace(/\(flip\)/g,'(flip 0.5)')
    var tokens = tokenize(church_codestring)
    var church_ast = church_astify(tokens)
    var js_ast = js_astify(church_ast)
    
    return trace_and_backtrace(js_ast)
}


//trace through an AST, using a current env as the base env, recording trace. then parse, and backtrace to propogate conditions as far back as possible. then addConditions to the trace code. return the final traced code.
function trace_and_backtrace(ast,env) {
    var old_trace = global_trace
    global_trace = []
    
    //trace through the ast, if we escape return a value, make a return statement, otherwise add value as final statement:
    var ret = ""
    try {
        ret = tracer(ast, new Environment(env))
        ret = "\n"+valString(ret)+";"
    } catch (e) {
        if (e.thrown_return) {
            ret = "\nreturn "+valString(e.val)+";"
        } else {
            throw e
        }
    }
    
    var new_ast = esprima.parse(global_trace.join("\n"))
    var cond = backTrace(new_ast)
    var new_trace = addConditions(global_trace.join("\n"),cond)
    new_trace = new_trace + ret
    global_trace = old_trace
    return new_trace
}


function trace_closure(body, params, env) {
    //extend environment with abstracts for params:
    var closureenv = new Environment(env)
    var newparams = []
    for(var p in params) {
        var ab = new Abstract()
        newparams.push(ab)
        closureenv.bind(params[p].name,ab)
    }
//    ab_arguments = new Abstract()
//    closureenv.bind("arguments",ab_arguments) //make arguments keyword bound to new abstract
    var trace = trace_and_backtrace(body,closureenv)
    return "function("+newparams.map(valString).join(",")+"){"+trace+"}"
//    return "function("+newparams.map(valString).join(",")+"){"+valString(ab_arguments)+"=arguments;"+trace+"}"
}





var Environment = function Environment(baseenv) {
    this.base = baseenv
    this.bindings = {}
    this.depth = (baseenv==undefined)?0:(baseenv.depth+1)
}

Environment.prototype.bind = function Environment_bind(name, val) {
    this.bindings[name] = val
}

Environment.prototype.lookup = function Environment_lookup(name) {
    val = this.bindings[name]
    if((val == undefined) && this.base) {return this.base.lookup(name)}
    return val
}


//the abstract value class:
var AbstractId = 0
function nextId(){return AbstractId++}
function Abstract() {
    this.id = "ab"+nextId()
}

function isAbstract(a) {return a instanceof Abstract}
function isClosure(fn) {return fn && fn.type && (fn.type == 'FunctionExpression')}

//convert a computed value to a string to put in a trace:
function valString(ob) {
    if (ob instanceof Array) {
        if(ob.length==0){return "[]"}
        var ret = "["
        for(var v in ob){
            ret = ret + valString(ob[v])+","
        }
        return ret.slice(0,-1)+"]"
    }
    if (isAbstract(ob)){
        return ob.id
    }
    if (isClosure(ob)) {
//        throw new Error("Tracer valString received closure object. That makes it sad.")
        return escodegen.generate(ob) //FIXME: doesn't capture env variables.
    }
    if (typeof ob === "boolean"
        || typeof ob === "number") {
        return ob.toString()
    }
    if (typeof ob === "string") {
        return "'"+ob.toString()+"'"
    }
    if (typeof ob === "undefined") {
        return "undefined"
    }
    if (typeof ob == "function") {
        return ob.sourcename //the original id in the js environment.
    }
    //otherwise generate json parsable representation:
    var json = JSON.stringify(ob)
    if(json == undefined){
        throw new Error("Tracer valString() dosen't know how to convert "+ob+" to a string.")
    } else {
        return "JSON.parse('" + json + "')"
    }
}


var max_trace_depth = 1000
global_trace=[]

//an abstract interpreter / tracer.
//a normal interpreter except for certain cases where there is an abstract value. then emit a statement into the trace.
function tracer(ast, env) {
    env = (env==undefined?new Environment():env)
//    console.log(env.depth)
//        console.log("tracer: ",ast)
//    console.log("tracer, trace so far: ",global_trace)
//    console.log(env)
    switch (ast.type) {
            //First the statements:
        case 'Program':
        case 'BlockStatement':
            var ret
            for (a in ast.body) {
                ret = tracer(ast.body[a],env)
            }
            return ret
            
        case 'ExpressionStatement':
            return tracer(ast.expression, env)
            
            //comment out because church compile uses ternary op, not if...
            //        case 'IfStatement':
            //            var test = tracer(ast.test,env)
            //            if(test instanceof Abstract) {
            //                var ret = new Abstract()
            //                var cons = tracer(ast.consequent,env)
            //                cons = (cons instanceof Abstract)? cons.id : cons //FIXME to string?
            //                var alt = tracer(ast.alternate, env)
            //                alt = (alt instanceof Abstract)? alt.id : alt
            //                var tracestring = "var "+ret.id+" = "+test.id+"?"+cons+":"+alt+";"
            //                global_trace.push(tracestring)
            //
            //                return ret
            //            }
            //            return test?tracer(ast.consequent,env):tracer(ast.alternate, env)
            
        case 'ReturnStatement':
            var val = tracer(ast.argument, env)
            var e ={thrown_return: true, val: val}
            throw e
            
        case 'VariableDeclaration':
            env.bind(ast.declarations[0].id.name, tracer(ast.declarations[0].init,env))
            return undefined
            
            
            //Next the expresisons:
        case 'FunctionExpression':
            //represent a closure as the FunctionExpression AST with a field for enclosing env.
//            //eagerly trace through closures:
//            var clostrace = trace_closure(ast.body,ast.params,env)
//            var newast = esprima.parse("var dummy ="+clostrace).body[0].declarations[0].init //esprima can't directly parse function so wrap in id...
//            newast.env = env
            ast.env = env
            return ast
            
        case 'ArrayExpression':
            var ret = []
            for (a in ast.elements) {
                ret.push(tracer(ast.elements[a],env))
            }
            return ret
            
        case 'UnaryExpression':
            var op
            switch (ast.operator) {
                case "-": op = "church_builtins.minus"; break;
                default: throw new Error("Tracer doesn't know how to handle Unary Operator: ",ast.operator)
            }
            ast.callee = {type: 'Identifier', name: op}
            ast.arguments = [ ast.argument ]
        case 'CallExpression':
            var args = []
            var abstract_args=false
            for(var a in ast.arguments) {
                var val = tracer(ast.arguments[a], env)
                args.push(val)
                if(isAbstract(val) || isClosure(val)) {abstract_args=true}
            }
            var fn = tracer(ast.callee,env)
            
            if(isClosure(fn)) {
                if(env.depth==max_trace_depth) {
                    //depth maxed out, don't trace branches, just generate code for this call:
                    var ret = new Abstract()
                    global_trace.push("var "+ret.id +" = "+escodegen.generate(ast))
                    console.log("Tracer warning: max_trace_depth reached, generating original code. (This might be broken.)")
                    return ret
                }
                var callenv = new Environment(fn.env)
                callenv.bind("arguments",args) //make arguments keyword bound to current call args
                for(a in fn.params) {
                    callenv.bind(fn.params[a].name,args[a]) //bind args to params
                }
                try {
                    tracer(fn.body,callenv)
                } catch (e) {
                    if (e.thrown_return) {return e.val}
                    throw e
                }
                return undefined
            }
            
            //if callee isn't a closure and operator or any args are abstract, emit new assignment into trace.
            //if the fn is list or pair, go ahead and do it, even with abstract args to ennable allocation removal. NOTE: could abstracts in lists screw up other things?
            var isadtcons = (fn == church_builtins.list) || (fn == church_builtins.pair)
            if(isAbstract(fn) || (abstract_args && !isadtcons)) {
                var ret = new Abstract()
                if(isAbstract(fn)){var fnstring = valString(fn)} else {var fnstring = escodegen.generate(ast.callee)}
                var argstrings = []
                for(var a in args){
//                    argstrings.push(valString(args[a]))
                    //if arg is a closure eagerly evaluate it to a trace.
                    if(isClosure(args[a])) {
                        //TODO: we trace closures more times than needed. trace when closure is created?
                        argstrings.push(trace_closure(args[a].body,args[a].params,args[a].env))
                    } else {
                        argstrings.push(valString(args[a]))
                    }
                }
                global_trace.push("var "+ret.id+" = "+fnstring+"("+argstrings.join(",")+");")
                return ret
            }
            //otherwise just do the fn:
            return fn.apply(fn,args)
            
            
        case 'ConditionalExpression':
            var test = tracer(ast.test,env)
            if(isAbstract(test)) {
                var ret = new Abstract()
                global_trace.push("if("+valString(test)+") {")
                var cons = valString(tracer(ast.consequent,env))
                global_trace.push("var "+ret.id+" = "+cons +";}")
                global_trace.push(" else {")
                var alt = valString(tracer(ast.alternate, env))
                global_trace.push("var "+ret.id+" = "+alt +";}")
                return ret
            }
            return test?tracer(ast.consequent,env):tracer(ast.alternate, env)
            
        case 'MemberExpression':
            var ob = tracer(ast.object,env)
            if (!ast.computed) {
                var v = ob[ast.property.name]
                if(v instanceof Object){v.sourcename = ob.sourcename+"."+ast.property.name}
                return v
            } else {
                throw new Error("Have not implemented computed member reference.")
            }
            
        case 'Identifier':
            //lookup in interpreter environment:
            var v = env.lookup(ast.name)
            //if not found, assume it will be defined in js environment for interpreter:
            if(v == undefined){
                v = eval(ast.name); //FIXME: better way to do this?
                if(v instanceof Object){v.sourcename = ast.name}
            }
            return v
            
        case 'Literal':
            return ast.value
            
        default:
            throw new Error("Tracer dosen't know how to handle "+ast.type+" in: "+escodegen.generate(ast))
    }
}


/*
 Interpret a trace backward, accumulating conditions.
 This is a version of Dijkstra's algorithm for weakest preconditions, but generates simple statements so that a CSP/proof system isn't needed (means can't handle eg disjunction cleverly).
 
 Conditions are sets of allowable values for variables.
 */
function Condition(cond) {
    this.conditions = {}
    this.erpvals = {}
    var oldconds = cond?cond.conditions:{}
    for (v in oldconds) {this.conditions[v] = oldconds[v]}
    var olderpvals = cond?cond.erpvals:{}
    for (v in olderpvals) {this.erpvals[v] = olderpvals[v]}
}

Condition.prototype.add = function add(v,c) {
    this.conditions[v]=c
}
Condition.prototype.get = function get(v) {
    return this.conditions[v]
}
Condition.prototype.remove = function remove(v) {
    delete this.conditions[v]
}
Unsatisfiable = new Object

function backTrace(ast, cond) {
    cond = (cond==undefined)?new Condition : cond
//    console.log("backtrace: ", ast, cond, "\n")
    switch (ast.type) {
            //First the statements:
        case 'Program':
        case 'BlockStatement':
            //we evaluate a sequence in *reverse* order:
            for (var i=ast.body.length-1;i>=0;i--) {
                cond = backTrace(ast.body[i],cond)
            }
            return cond
            
            //        case 'ExpressionStatement':
            //            return backTrace(ast.expression, cond)
            
        case 'VariableDeclaration':
            //Assume that a variable declaration has one of the forms:
            //  "var ab = condition(ab);"
            //  "var ab = random(ab);"
            //  "var ab = op(ab,..);" where op might be dotted, and the arguments may be identifiers or literals.
            //  "var ab = literal;"
            //  "var ab = ab;"
            //
            //We add a condition when it's a condition statement, otherwise check if the declared variable is constrained and if so see if we can push that constraint into the init.
            //If op is random the we should emit a direct conditioning statement.
            
            var name = ast.declarations[0].id.name
            var init = ast.declarations[0].init
            var varcond = cond.get(name)
            
            if(init.type=="CallExpression" &&
               init.callee.type=="Identifier" &&
               init.callee.name=="condition") {
                //assume form is "var ab1 = condition(ab2)"
                cond.add(init.arguments[0].name, true)
                return cond
            }
            
            if(varcond==undefined){return cond} else {
                switch (init.type) {
                    case "Literal":
                        //if variable is assigned a value, check if that's consistent with cond:
                        if(init.value != varcond) {
                            return Unsatisfiable
                        }
                        cond.remove(name)//have handled the cond on this var.
                        return cond
                        
                    case "Identifier":
                        //if variable is assigned a variable, propogate condition:
                        cond.add(init.name,varcond)
                        cond.remove(name)//have handled the cond on this var.
                        return cond
                        
                        
                    case "CallExpression":
                        if(init.callee.type=="Identifier"){
                            var opname = init.callee.name
                        } else if (init.callee.type == "MemberExpression") {
                            //FIXME: just deal with church_builtins
                            var opname = init.callee.property.name
                        } else {
                            var opname = undefined
                        }
                        switch (opname) {
                            case "random":
                                if(varcond != undefined){
                                    cond.remove(name)//have handled the cond on this var.
                                    cond.erpvals[name] = varcond
                                }
//                                    console.log("Random choice at "+name+" should be conditioned to value "+varcond)}
                                break
                                
                            case "eq":
                            case "is_eq":
                                if(varcond == true) {
                                    //if either arg is a literal, set other to it.
                                    if(init.arguments[0].type == "Literal"){
                                        var argname = init.arguments[1].name
                                        var argval = init.arguments[0].value
                                        cond.add(argname,argval)
                                        cond.remove(name)//have handled the cond on this var.
                                    } else if(init.arguments[1].type == "Literal"){
                                        var argname = init.arguments[0].name
                                        var argval = init.arguments[1].value
                                        cond.add(argname,argval)
                                        cond.remove(name)//have handled the cond on this var.
                                    }
                                }
                                break
                                
                            case "and":
                                if(varcond == true) {
                                    //add condition for each argument:
                                    for(var a in init.arguments) {
                                        var argname = init.arguments[a].name
                                        cond.add(argname,true)
                                    }
                                    cond.remove(name)//have handled the cond on this var.
                                }
                                break
                        }
                        return cond
                }}
            
        case 'IfStatement':
            // "if(ab1){SC} else {SA}"
            //push condition through each branch of 'if', we want condition a1?cond(SC):cond(SA), but we don't want to handle arbirary terms, so: if either branch undition is unsatisfiable add a1 = true/false to and return that branch condition. otherwise return original condition (ie don't push conditions into this 'if').
            var testvar = ast.test.name
            //            console.log("consequent");console.log(ast.consequent)
            var condC = backTrace(ast.consequent,new Condition(cond))
            var condA = backTrace(ast.alternate,new Condition(cond))
            if(condC == Unsatisfiable) {
                condA.add(testvar, false)
                return condA
            } else if (condA == Unsatisfiable) {
                condC.add(testvar, true)
                return condC
            }
            return cond
            
            //        case 'ArrayExpression':
            
            //        case 'MemberExpression':
            
            
        default:
            throw new Error("Backtrace can't handle "+ast.type)
    }
}


/*
 Take a set of conditions computed by backTrace, and the code string, and insert condition or conditioned erp statements as needed.
 */
function addConditions(string, cond) {
    var lines = string.split("\n")
    //first remove old conditions:
    lines.filter(function(l){!l.match(/condition\(/)})
    
    newlines = []
    for(l in lines) {
                 
        var m = lines[l].match(/var (.+) = (.+)/)

        if (m && m[2].match(/condition\(/)) {
            // remove old conditions by not doing anything with this line.
            
        } else if(m && m[1] in cond.conditions) {
            // add conditions that didn't make it all the way to erps:
            newlines.push(lines[l])
            var condval = cond.conditions[m[1]]
            newlines.push("condition("+m[1]+"=="+condval+");")
        } else if(m && m[1] in cond.erpvals) {
            //then add conditioned erp calls:
            var name = m[1], init = m[2]
            var k = init.match(/random\((.+)\)/)
//            newlines.push("condition("+m[1]+"=="+cond.erpvals[m[1]]+");")
            newlines.push("var "+name+" = random("+k[1]+", "+cond.erpvals[m[1]]+");")
        } else {
            newlines.push(lines[l])
        }
    }
    return newlines.join("\n")
}
            


            


module.exports =
{
    //    interpret : interpret,
tracer: tracer,
global_trace: global_trace,
backTrace: backTrace,
addConditions: addConditions,
            trace_and_backtrace: trace_and_backtrace,
            precompile: precompile
}


