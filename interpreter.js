/*
A very simple (abstract/tracing) interpreter that takes in the AST generated by js_astify.js. Inteprets only a fragment of javascript (eg does not deal with objects, loops, etc.
Nothing fancy here.
*/

var escodegen = require('escodegen');
var church_builtins = require('./church_builtins');
var erp = require('./probabilistic/erp.js')
// make erp exports directly avaialable (gnarly use of eval to get in scope):
for (var prop in erp) {
    eval(prop + "= erp."+prop)
}



//Use flat environment structure. later bindings will overwrite (hence shadow) earlier. This means must copy env on (compound) function application. Do this by using the constructor...
var Environment = function Environment(oldenv) {
    oldbindings = (oldenv==undefined)?{}:oldenv.bindings
    this.bindings = {}
    for(n in oldbindings) {
        this.bindings[n] = oldbindings[n]
    }
}

Environment.prototype.bind = function Environment_bind(name, val) {
    this.bindings[name] = val
}

Environment.prototype.lookup = function Environment_lookup(name) {
    val = this.bindings[name]
//    if (val == undefined) {throw new Error("Variable "+name+" is undefined.")}
    return val
}


function interpret(ast, env) {
    env = (env==undefined?new Environment():env)
    var ret
    switch (ast.type) {
        //First the statements:
        case 'Program':
        case 'BlockStatement':
            var ret
            for (a in ast.body) {
                ret = interpret(ast.body[a],env)
            }
            return ret
            
        case 'ExpressionStatement':
            return interpret(ast.expression, env)
            
        case 'IfStatement':
            var test = interpret(ast.test,env)
            return test?interpret(ast.consequent,env):interpret(ast.alternate, env)
            
        case 'ReturnStatement':
            var val = interpret(ast.argument, env)
            var e ={thrown_return: true, val: val}
            throw e
            
        case 'VariableDeclaration':
            env.bind(ast.declarations.id.name, inerpret(ast.declarations.init,env))
            return undefined
            
            
        //Next the expresisons:
        case 'FunctionExpression':
            //represent a closure as the AST extended by an env field, which is a copy of current env.
            ast.env = new Environment(env)
            return ast
            
        case 'MemberExpression':
            var ob = interpret(ast.object,env)
            if (!ast.computed) {
                return ob[ast.property.name]
            } else {
                throw new Error("Have not implemented computed member reference.")
            }
            
        case 'ArrayExpression':
            var ret = []
            for (a in ast.elements) {
                ret.push(interpret(ast.elements[a],env))
            }
            return ret
            
        case 'CallExpression':
            var fn = interpret(ast.callee,env)
            var args = []
            for(a in ast.arguments) {
                args.push(interpret(ast.arguments[a], env))
            }
            if(fn.type && (fn.type == 'FunctionExpression')) {
                for(a in args) {
                    fn.env.bind(fn.params[a].name,args[a])
                }
                try {
                    interpret(fn.body,fn.env)
                } catch (e) {
                    if (e.thrown_return) {return e.val}
                    throw e
                }
                return undefined
            }
//            else {
//              //if callee is provided from erp.js, call it:
//                if(fn in erp) {
//                    erp[fn].apply(null,args)
//                }
//            }
            //if callee isn't a closure built by interpreter or an erp, assume its a js function already:
            return fn.apply(fn,args)
            
            
//        case 'ConditionalExpression':
        
            
        case 'Identifier':
            //lookup in interpreter environment:
            var v = env.lookup(ast.name)
            //if not found, assume it will be defined in js environment for interpreter:
            if(!v){v = eval(ast.name)} //FIXME: better way to do this?
            return v
            
        case 'Literal':
            return ast.value
        
        default:
            throw new Error("Don't know how to handle "+ast.type)
    }
}

//an abstract interpreter / tracer.
//there are now ordinary values and abstract sites.

//the abstract value class:
function Abstract() {
    this.id = nextId()
}

var AbstractId = 0
function nextId(){return AbstractId++}

function _newAbstractVal(){
    return new Abstract()
}

global_trace=[]

//the tracer. be a normal interpreter except for certain cases where there is an abstract value. then emit a statement into the trace.
function tracer(ast, env) {
    env = (env==undefined?new Environment():env)
    var ret
    switch (ast.type) {
            //First the statements:
        case 'Program':
        case 'BlockStatement':
            var ret
            for (a in ast.body) {
                ret = tracer(ast.body[a],env)
            }
            return ret
            
        case 'ExpressionStatement':
            return tracer(ast.expression, env)
            
        case 'IfStatement':
            var test = tracer(ast.test,env)
            if(test instanceof Abstract) {
                //FIXME: tracing both sides of if could lead to infinite recursion, but maybe not for cases we care about...
                var ret = new Abstract()
                var cons = tracer(ast.consequent,env)
                cons = (cons instanceof Abstract)? "ab"+cons.id : cons //FIXME to string?
                var alt = tracer(ast.alternate, env)
                alt = (alt instanceof Abstract)? "ab"+alt.id : alt
                var tracestring = "var ab"+ret.id+" = ab"+test.id+"?"+cons+":"+alt+";"
                global_trace.push(tracestring)

                return ret
            }
            return test?tracer(ast.consequent,env):tracer(ast.alternate, env)
            
        case 'ReturnStatement':
            var val = tracer(ast.argument, env)
            var e ={thrown_return: true, val: val}
            throw e
            
        case 'VariableDeclaration':
            env.bind(ast.declarations.id.name, inerpret(ast.declarations.init,env))
            return undefined
            
            
            //Next the expresisons:
        case 'FunctionExpression':
            //represent a closure as the AST extended by an env field, which is a copy of current env.
            ast.env = new Environment(env)
            return ast
            
        case 'MemberExpression':
            var ob = tracer(ast.object,env)
            if (!ast.computed) {
                return ob[ast.property.name]
            } else {
                throw new Error("Have not implemented computed member reference.")
            }
            
        case 'ArrayExpression':
            var ret = []
            for (a in ast.elements) {
                ret.push(tracer(ast.elements[a],env))
            }
            return ret
            
        case 'CallExpression':
            var args = []
            var abstract_args=false
            for(a in ast.arguments) {
                var val = tracer(ast.arguments[a], env)
                args.push(val)
                if(val instanceof Abstract) {abstract_args=true}
            }
            var fn = tracer(ast.callee,env)
            
            if(fn.type && (fn.type == 'FunctionExpression')) {
                for(a in args) {
                    fn.env.bind(fn.params[a].name,args[a])
                }
                try {
                    tracer(fn.body,fn.env)
                } catch (e) {
                    if (e.thrown_return) {return e.val}
                    throw e
                }
                return undefined
            }
            //            else {
            //              //if callee is provided from erp.js, call it:
            //                if(fn in erp) {
            //                    erp[fn].apply(null,args)
            //                }
            //            }
            //if callee isn't a closure and any args are abstract, emit new assignment into trace:
            if(abstract_args) {
                var ret = new Abstract()
                var fnstring = escodegen.generate(ast.callee)
                tracestring = "var ab"+ret.id+" = "+fnstring+"("
                for(a in args){
                    if(args[a] instanceof Abstract) {
                        tracestring = tracestring + " ab"+args[a].id+","
                    }
                    else {
                        tracestring = tracestring + " " + args[a] + ","
                    }
                }
                global_trace.push(tracestring.slice(0,-1)+");")
                return ret
            }
            //otherwise just do the fn:
            return fn.apply(fn,args)
            
            
        case 'ConditionalExpression':
            var test = tracer(ast.test,env)
            if(test instanceof Abstract) {
                //FIXME: tracing both sides of if could lead to infinite recursion, but maybe not for cases we care about...
                var ret = new Abstract()
                var cons = tracer(ast.consequent,env)
                cons = (cons instanceof Abstract)? "ab"+cons.id : cons //FIXME to string?
                var alt = tracer(ast.alternate, env)
                alt = (alt instanceof Abstract)? "ab"+alt.id : alt
                var tracestring = "var ab"+ret.id+" = ab"+test.id+"?"+cons+":"+alt+";"
                global_trace.push(tracestring)
                
                return ret
            }
            return test?tracer(ast.consequent,env):tracer(ast.alternate, env)
            
            
        case 'Identifier':
            //lookup in interpreter environment:
            var v = env.lookup(ast.name)
            //if not found, assume it will be defined in js environment for interpreter:
            if(!v){v = eval(ast.name)} //FIXME: better way to do this?
            return v
            
        case 'Literal':
            return ast.value
            
        default:
            throw new Error("Don't know how to handle "+ast.type)
    }
}



module.exports =
{
    interpret : interpret,
    tracer: tracer,
global_trace: global_trace
}