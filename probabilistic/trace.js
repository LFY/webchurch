var util = require("./util")

// Toggle for switching between different variable naming implementations
// NOTE: The 'false' implementation has an issue with recursion (see the 
// 	'geStack' implementation below). This is fixable by always returning
// 	the full stack trace, but that will make this implementation extremely
// 	slow (it is already slower than the 'true' implementation). So, let's
//	just consider the 'false' implementation deprecated or some such.
var maintainOwnStack = true
var nameStack = []

/*
Mapping (potentially long) absolute file names to unique integers 
*/
var fileNameTable =
{
	currId: 0,
	table: {},
	idForName: function(name)
	{
		var id = this.table[name]
		if (id == undefined) { id = this.currId++; this.table[name] = id }
		return id;
	}
}

/*
Code adapated from https://github.com/visionmedia/callsite/blob/master/index.js
*/
function getStack(numToSkip, numToGet)
{
	numToSkip = numToSkip || 0
	numToGet = numToGet || Infinity

	var origLimit = Error.stackTraceLimit
	Error.stackTraceLimit = numToGet

	var top = arguments.callee
	for (var i = 0; i < numToSkip; i++)
	{
		top = top.caller	// NOTE: This will not work with recursion!!!
	}

	var orig = Error.prepareStackTrace
	Error.prepareStackTrace = function(_, stack){ return stack }
	var err = new Error
	Error.captureStackTrace(err, top)
	var stack = err.stack

	Error.prepareStackTrace = orig
	Error.stackTraceLimit = origLimit

	return stack;
}

/*
All probabilistic function definitions must be wrapped with this decorator
so that they can be tagged with a lexically unique name (unfortunately, V8
doesn't expose details about where a function was defined *grumble*)
*/
var prob = null
if (maintainOwnStack)
{
	prob = function prob(fn)
	{
		var frame = getStack(1, 1)[0]
		var fileName = frame.getFileName()
		var uniqId = fileNameTable.idForName(fileName)
		var fnName = ['(', uniqId, frame.pos, ')'].join(':')
		fn.__probabilistic_lexical_id = fnName
		return function()
		{
			// If there is no active trace, or if this is the root call (the call to traceUpdate),
			// then there's no need to track names (the second case only happens with nested query)
			if (trace && fn != trace.rootframe)
			{
				var frame = getStack(1, 1)[0]
				if (!frame.getFunction().__probabilistic_lexical_id)
				{
					var fnname = frame.getFunction().name || "<anonymous>"
					throw new Error("Function '" + fnname + "' was not decorated with 'prob'")
				}
				// Including the root frame makes names unnecessarily long, so skip it
				if (frame.getFunction() != trace.rootframe)
				{
					nameStack.push(frame.getFunction().__probabilistic_lexical_id)
					nameStack.push(frame.pos)
					nameStack.push(trace.loopcounters[nameStack.join(':')] || 0)
					var retval = fn.apply(this, arguments)
					nameStack.length -= 3
					return retval
				}
				else return fn.apply(this, arguments)
			}
			else return fn.apply(this, arguments)
		}
	}
}
else
{
	prob = function prob(fn)
	{
		var frame = getStack(1, 1)[0]
		var fileName = frame.getFileName()
		var uniqId = fileNameTable.idForName(fileName)
		var fnName = ['(', uniqId, frame.pos, ')'].join(':')
		fn.__probabilistic_lexical_id = fnName
		return fn
	}
}


/*
Variables generated by ERPs
*/
function RandomVariableRecord(name, erp, params, val, logprob, structural, conditioned)
{
	this.name = name
	this.erp = erp
	this.params = params
	this.val = val
	this.logprob = logprob
	this.active = true
	this.structural = structural
	this.conditioned = conditioned
}

RandomVariableRecord.prototype.copy = function copy()
{
	return new RandomVariableRecord(this.name, this.erp, this.params, this.val,
									this.logprob, this.structural, this.conditioned)
}


/*
Execution trace generated by a probabilistic program.
Tracks the random choices made and accumulates probabilities.
*/
function RandomExecutionTrace(computation, doRejectionInit)
{
	doRejectionInit = (doRejectionInit == undefined ? true : doRejectionInit)
	this.computation = computation
	this.vars = {}
	this.varlist = []
	this.currVarIndex = 0
	this.logprob = 0.0
	this.newlogprob = 0.0
	this.oldlogprob = 0.0
	this.rootframe = null
	this.loopcounters = {}
	this.conditionsSatisfied = false
	this.returnValue = null

	if (doRejectionInit)
	{
		while (!this.conditionsSatisfied)
		{
			this.vars = {}
			this.traceUpdate()
		}
	}
}

RandomExecutionTrace.prototype.deepcopy = function deepcopy()
{
	var newdb = new RandomExecutionTrace(this.computation, false)
	newdb.logprob = this.logprob
	newdb.oldlogprob = this.oldlogprob
	newdb.newlogprob = this.newlogprob
	newdb.conditionsSatisfied = this.conditionsSatisfied
	newdb.returnValue = this.returnValue

	for (var i = 0; i < this.varlist.length; i++)
	{
		var newvar = this.varlist[i].copy()
		newdb.varlist.push(newvar)
		newdb.vars[newvar.name] = newvar
	}

	return newdb
}

RandomExecutionTrace.prototype.freeVarNames = function freeVarNames(structural, nonstructural)
{
	structural = (structural == undefined ? true : structural)
	nonstructural = (nonstructural == undefined ? true : nonstructural)
	var names = []
	for (var name in this.vars)
	{
		var rec = this.vars[name]
		if (!rec.conditioned &&
			((structural && rec.structural) || (nonstructural && !rec.structural)))
			names.push(name)
	}
	return names
}

/*
Names of variables that this trace has that the other does not
*/
RandomExecutionTrace.prototype.varDiff = function varDiff(other)
{
	var arr = []
	for (var name in this.vars)
	{
		if (!other.vars[name])
			arr.push(name)
	}
	return arr
}

/*
Difference in log probability between this trace and the other
due to variables that this one has that the other does not
*/
RandomExecutionTrace.prototype.lpDiff = function lpDiff(other)
{
	return this.varDiff(other)
		.map(function(name) {return this.vars[name].logprob}.bind(this))
		.reduce(function(a,b) {return a+b}, 0)
}

/*
The singleton trace object
*/
var trace = null

/*
Run computation and update this trace accordingly
*/
RandomExecutionTrace.prototype.traceUpdate = prob(function traceUpdate(structureIsFixed)
{
	var origtrace = trace
	trace = this

	this.logprob = 0.0
	this.newlogprob = 0.0
	this.loopcounters = {}
	this.conditionsSatisfied = true
	this.currVarIndex = 0

	// If updating this trace can change the variable structure, then we
	// clear out the flat list of variables beforehand
	if (!structureIsFixed)
		this.varlist.length = 0

	// Mark all variables as inactive; only those reached
	// by the computation will become active
	for (var name in this.vars)
		this.vars[name].active = false

	// Mark that this is the 'root' frame of the computation
	this.rootframe = getStack(0, 1)[0].getFunction()

	// Run the computation, creating/looking up random variables
	this.returnValue = this.computation()

	// Clean up
	this.rootframe = null
	this.loopcounters = {}

	// Clear out any random values that are no longer reachable
	var newvars = {}
	this.oldlogprob = 0.0
	for (var name in this.vars)
	{
		var rec = this.vars[name]
		if (!rec.active)
			this.oldlogprob += rec.logprob
		else
			newvars[name] = rec
	}
	this.vars = newvars

	// Reset the original singleton trace
	trace = origtrace
})

/*
Propose a random change to a random variable 'varname'
Returns a new sample trace from the computation and the
forward and reverse probabilities of this proposal
*/
RandomExecutionTrace.prototype.proposeChange = function proposeChange(varname, structureIsFixed)
{
	var nextTrace = this.deepcopy()
	var v = nextTrace.getRecord(varname)
	var propval = v.erp.proposal(v.val, v.params)
	var fwdPropLP = v.erp.logProposalProb(v.val, propval, v.params)
	var rvsPropLP = v.erp.logProposalProb(propval, v.val, v.params)
	v.val = propval
	v.logprob = v.erp.logprob(v.val, v.params)
	nextTrace.traceUpdate(structureIsFixed)
	fwdPropLP += nextTrace.newlogprob
	rvsPropLP += nextTrace.oldlogprob
	return [nextTrace, fwdPropLP, rvsPropLP]
}

/*
Return the current structural name, as determined by the interpreter stack
*/
if (maintainOwnStack)
{
	RandomExecutionTrace.prototype.currentName = function currentName(numFrameSkip)
	{
		var nameMinusLoopCounter = nameStack.slice(0,-1).join(':')
		var loopnum = this.loopcounters[nameMinusLoopCounter] || 0
		this.loopcounters[nameMinusLoopCounter] = loopnum + 1
		var name = nameMinusLoopCounter + ":" + nameStack[nameStack.length-1]
		return name
	}
}
else
{
	RandomExecutionTrace.prototype.currentName = function currentName(numFrameSkip)
	{
		// Get list of stack frames
		var frames = []
		var ii = 0
		var k = numFrameSkip+1
		//var f = getStack(k, 1)[0]		// This has problems...
		var f = getStack(1, k)[k-1]
		var rootid = this.rootframe.__probabilistic_lexical_id
		while (f && rootid !== f.getFunction().__probabilistic_lexical_id)
		{
			if (!f.getFunction().__probabilistic_lexical_id)
			{
				var fnname = f.getFunctionName() || "<anonymous>"
				throw new Error("Function '" + fnname + "' was not decorated with 'prob'")
			}
			frames[ii] = f
			ii++
			k++
			f = getStack(k, 1)[0]
		}
		var i = frames.length-1
		if (frames.length == 0) throw new Error("No stack frames available! JIT weirdness?")

		// Build up name string, checking loop counters along the way
		var name = ""
		var loopnum = 0
		var f = null
		for (var j = i; j > 0; j--)
		{
			f = frames[j]
			name += f.getFunction().__probabilistic_lexical_id
			name += ":"
			name += f.pos
			loopnum = (this.loopcounters[name] || 0)
			name += ":"
			name += loopnum
			name += "|"
		}
		// For the last (topmost) frame, also increment the loop counter
		f = frames[0]
		name += f.getFunction().__probabilistic_lexical_id
		name += ":"
		name += f.pos
		loopnum = (this.loopcounters[name] || 0)
		this.loopcounters[name] += 1
		name += ":"
		name += loopnum

		//console.log(name)
		return name
	}
}

/*
Looks up the value of a random variable.
Creates the variable if it does not already exist
*/
RandomExecutionTrace.prototype.lookup = function lookup(erp, params, numFrameSkip, isStructural, conditionedValue)
{
	var record = null
	var name = null

	// Try to find the variable (first check the flat list, then do 
	// slower structural lookup)
	var varIsInFlatList = this.currVarIndex < this.varlist.length
	if (varIsInFlatList)
		record = this.varlist[this.currVarIndex]
	else
	{
		name = this.currentName(numFrameSkip + 1)
		record = this.vars[name]
		if (!record || record.erp != erp || record.structural != isStructural)
			record = null
	}
	// If we didn't find the variable, create a new one
	if (!record)
	{
		var val = conditionedValue || erp.sample_impl(params)
		var ll = erp.logprob(val, params)
		this.newlogprob += ll
		record = new RandomVariableRecord(name, erp, params, val, ll, isStructural, conditionedValue !== undefined)
		this.vars[name] = record
	}
	// Otherwise, reuse the variable we found, but check if its parameters/conditioning
	// status have changed
	else
	{
		record.conditioned = (conditionedValue != undefined)
		var hasChanges = false
		if (!util.arrayEquals(record.params, params))
		{
			record.params = params
			hasChanges = true
		}
		if (conditionedValue && conditionedValue != record.val)
		{
			record.val = conditionedValue
			record.conditioned = true
			hasChanges = true
		}
		if (hasChanges)
			record.logprob = erp.logprob(record.val, record.params)
	}
	// Finish up and return
	if (!varIsInFlatList)
		this.varlist.push(record)
	this.currVarIndex++
	this.logprob += record.logprob
	record.active = true
	return record.val
}

// Simply retrieve the variable record associated with 'name'
RandomExecutionTrace.prototype.getRecord = function getRecord(name)
{
	return this.vars[name]
}

// Add a new factor into the log-likelihood of this trace
RandomExecutionTrace.prototype.addFactor = function addFactor(num)
{
	this.logprob += num
}

// Condition the trace on the value of a boolean expression
RandomExecutionTrace.prototype.conditionOn = function conditionOn(boolexpr)
{
	this.conditionsSatisfied &= boolexpr
}



// Exported functions for interacting with the global trace

function lookupVariableValue(erp, params, isStructural, numFrameSkip, conditionedValue)
{
	if (!trace)
	{
		return conditionedValue || erp.sample_impl(params)
	}
	else
	{
		return trace.lookup(erp, params, numFrameSkip+1, isStructural, conditionedValue)
	}
}

function newTrace(computation)
{
	return new RandomExecutionTrace(computation)
}

function factor(num)
{
	if (trace)
		trace.addFactor(num)
}

function condition(boolexpr)
{
	if (trace)
		trace.conditionOn(boolexpr)
}


module.exports =
{
	prob: prob,
	lookupVariableValue: lookupVariableValue,
	newTrace: newTrace,
	factor: factor,
	condition: condition
}